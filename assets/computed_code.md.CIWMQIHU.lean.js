import{_ as p,c as e,a0 as l,o as h}from"./chunks/framework.BFeFTQGI.js";const i="/vue-next-blog/assets/cache-1.DDQtqDmB.png",k="/vue-next-blog/assets/cache-2.DHJPQS4d.png",d="/vue-next-blog/assets/cache-3.CUi5SWcr.png",a="/vue-next-blog/assets/cache-4.BEuHQTCX.png",n="/vue-next-blog/assets/cache-6.CopRpVqf.png",t="/vue-next-blog/assets/cache-7.c_iqdHsv.png",c="/vue-next-blog/assets/cache-8.BPYIX9mA.png",r="/vue-next-blog/assets/cache-9.COGMPAN6.png",E="/vue-next-blog/assets/cache-10.Bpk5D1ra.png",g="/vue-next-blog/assets/cache-11.DobfpCXs.png",o="/vue-next-blog/assets/cache-12.rBuDzWFy.png",y="/vue-next-blog/assets/cache-13.Bs6YrZbf.png",F="/vue-next-blog/assets/cache-14.CtuQpjfq.png",f="/vue-next-blog/assets/cache-15.CpdCjsGe.png",u="/vue-next-blog/assets/cache-16._PYiFCGT.png",A="/vue-next-blog/assets/cache-17.7hNXZhEh.png",D="/vue-next-blog/assets/cache-18.BFznyAq2.png",C="/vue-next-blog/assets/cache-19.BMsz1NK5.png",m="/vue-next-blog/assets/cache-20.CCm-ZcXY.png",V=JSON.parse('{"title":"computed的实现","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"computed/code.md","filePath":"computed/code.md"}'),v={name:"computed/code.md"};function B(b,s,_,x,R,j){return h(),e("div",null,s[0]||(s[0]=[l(`<h1 id="computed的实现" tabindex="-1">computed的实现 <a class="header-anchor" href="#computed的实现" aria-label="Permalink to &quot;computed的实现&quot;">​</a></h1><p>对于 <code>computed</code> 函数的实现而言，由于他的内部逻辑非常非常的复杂，所以我们会简化内部的实现，分布来进行实现。</p><h2 id="构建-computedrefimpl-读取计算属性的值" tabindex="-1">构建 ComputedRefImpl ，读取计算属性的值 <a class="header-anchor" href="#构建-computedrefimpl-读取计算属性的值" aria-label="Permalink to &quot;构建 ComputedRefImpl ，读取计算属性的值&quot;">​</a></h2><p>我们首先的目标是：<strong>构建 <code>ComputedRefImpl</code> 类，创建出 <code>computed</code> 方法，并且能够读取值</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { isFunction } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;@vue/shared&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Dep } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./dep&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ReactiveEffect } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./effect&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { trackRefValue } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./ref&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * 计算属性类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ComputedRefImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	public</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> dep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> undefined</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	private</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> _value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> effect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReactiveEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> readonly</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> __v_isRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.effect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReactiveEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(getter)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.effect.computed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	get</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   		// 依赖收集</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   		trackRefValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   		// 执行 run 函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.effect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   		// 返回计算之后的真实值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * 计算属性</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> computed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getterOrOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> getter</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   	// 判断传入的参数是否为一个函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> onlyGetter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(getterOrOptions)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (onlyGetter) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   		// 如果是函数，则赋值给 getter</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   		getter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> getterOrOptions</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> cRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ComputedRefImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(getter)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cRef </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span></code></pre></div><h2 id="computed-的响应性-初见调度器-处理脏的状态" tabindex="-1">computed 的响应性：初见调度器，处理脏的状态 <a class="header-anchor" href="#computed-的响应性-初见调度器-处理脏的状态" aria-label="Permalink to &quot;computed 的响应性：初见调度器，处理脏的状态&quot;">​</a></h2><p>根据之前的代码可知，如果我们想要实现 <strong>响应性</strong>，那么必须具备两个条件：</p><ol><li>收集依赖：该操作我们目前已经在 <code>get value</code> 中进行。</li><li>触发依赖：该操作我们目前尚未完成，而这个也是我们本小节主要需要做的事情。</li></ol><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._dirty) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._dirty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    triggerRefValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个参数是一个匿名函数，被叫做 <code>scheduler</code> 调度器。</p><p>该匿名函数中，又涉及到了一个 <code>_dirty</code> 变量，该变量我们把它叫做 <strong>脏</strong>。</p><p>那么想要实现 <code>computed</code> 的响应性，就必须要搞明白这两个东西的概念：</p><h3 id="调度器" tabindex="-1">调度器 <a class="header-anchor" href="#调度器" aria-label="Permalink to &quot;调度器&quot;">​</a></h3><p>调度器 <code>scheduler</code> 是一个相对比较复杂的概念，它在 <code>computed</code> 和 <code>watch</code> 中都有涉及，但是在当前的 <code>computed</code> 实现中，它的作用还算比较清晰。</p><p>所以根据我们秉承的：<strong>没有使用就当做不存在</strong> 的理念，我们只需要搞清楚，它在当前的作用即可。</p><p>根据我们看的源码，我们可以知道，此时的 <code>scheduler</code> 就相当于一个 <strong>回调函数</strong>。</p><p>在 <code>triggerEffect</code> 只要 <code>effect</code> 存在 <code>scheduler</code>，则就会执行该函数。</p><h3 id="dirty-脏" tabindex="-1">_dirty 脏 <a class="header-anchor" href="#dirty-脏" aria-label="Permalink to &quot;_dirty 脏&quot;">​</a></h3><p>对于 <code>dirty</code> 而言，相对比较简单了。</p><p>它只是一个变量，我们只需要知道：<strong>它为 false 时，表示需要触发依赖。为 true 时表示需要重新执行 run 方法，获取数据。</strong> 即可。</p><ol><li><p>处理脏状态</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ComputedRefImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   	/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   	 * 脏：为 false 时，表示需要触发依赖。为 true 时表示需要重新执行 run 方法，获取数据。即：数据脏了</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   	 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	public</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> _dirty</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">getter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.effect </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReactiveEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(getter, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   			// 判断当前脏的状态，如果为 false，表示需要《触发依赖》</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   			if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._dirty) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   				// 将脏置为 true，表示</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   				this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._dirty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   				triggerRefValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   			}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   		})</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   		this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.effect.computed </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	get</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   		// 收集依赖</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">   		trackRefValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   		// 判断当前脏的状态，如果为 true ，则表示需要重新执行 run，获取最新数据</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._dirty) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   			this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._dirty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   			// 执行 run 函数</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">   			this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.effect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   		// 返回计算之后的真实值</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   		return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span></code></pre></div></li><li><p>添加 <code>scheduler</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectScheduler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * 响应性触发依赖时的执行类</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReactiveEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   	/**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   	 * 存在该属性，则表示当前的 effect 为计算属性的 effect</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   	 */</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">   	computed</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ComputedRefImpl</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   		public</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   		public</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> scheduler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EffectScheduler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   	) {}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   	...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span></code></pre></div></li><li><p>触发调度器函数</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    * 触发指定依赖</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> triggerEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">effect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReactiveEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 存在调度器就执行调度函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (effect.scheduler) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       effect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scheduler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     } </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     // 否则直接执行 run 函数即可</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       effect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   }</span></span></code></pre></div></li></ol><h2 id="computed-的缓存性" tabindex="-1">computed 的缓存性 <a class="header-anchor" href="#computed-的缓存性" aria-label="Permalink to &quot;computed 的缓存性&quot;">​</a></h2><p><code>computed</code> 区别于 <code>function</code> 最大的地方就是：<strong>computed 具备缓存</strong>，当多次触发计算实行时，那么计算属性只会计算 <strong>一次</strong>。</p><p>那么秉承着这样的一个理念，我们来创建一个测试用例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     const { reactive, computed, effect } = Vue</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     const obj = reactive({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;张三&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     const computedObj = computed(() =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;计算属性执行计算&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       return </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;姓名：&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.name</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     effect(() =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> computedObj.value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;#app&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).innerHTML </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> computedObj.value</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     setTimeout(() =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">       obj.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;李四&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">     }, 2000);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>运行到浏览器，我们发现当前代码出现了 <strong>死循环</strong> 的问题，</p><h3 id="为什么会出现死循环呢" tabindex="-1">为什么会出现死循环呢？ <a class="header-anchor" href="#为什么会出现死循环呢" aria-label="Permalink to &quot;为什么会出现死循环呢？&quot;">​</a></h3><p>我们为当前的代码进行 <code>debugger</code>，查看出现该问题的原因。我们知道这个死循环是在 <strong>延迟两秒后</strong> 出现的，而延迟两秒之后是 <code>obj.name</code> 的调用，</p><p>即： <code>reactive</code> 的 <code>setter</code> 行为被触发，也就是 <code>trigger</code> 方法触发时：</p><img src="`+i+'" alt="cache-1" style="zoom:50%;"><p>在 <code>effect.ts</code> 文件中打上断点，现在的 <code>target</code> 是 &#39;李四&#39;，也就是说当前 demo 中执行的是 <code>obj.name = &#39;李四&#39;</code> 这行代码，而依赖收集的过程已经在前面完成了，当断点执行到获取 <code>dep</code> 这里的时候，我们要注意的是 <code>depsMap</code> 是有值的，这是因为我们之前已经完成了依赖收集。</p><p><img src="'+k+'" alt="cache-2"></p><p>接下来进入 <code>triggerEffects</code> 函数，此时的 <code>effect</code> 就是一个 <code>computed</code> 的 <code>ReactiveEffect</code>，</p><p><img src="'+d+'" alt="cache-3"></p><p>因为这是一个 <code>computed</code> 的 <code>ReactiveEffect</code>， 接下来继续执行 <code>effect.scheduler()</code> 这个调度器回调函数。</p><p>进入这个回调函数中，因为现在的 <code>_dirty</code> 为 <code>false</code>，所以我们会继续执行 <code>triggerRefValue(this)</code>函数，也就是再次进行<strong>派发更新</strong>，</p><p><img src="'+a+'" alt="cache-4"></p><p>进入 <code>triggerRefValue(this)</code>函数中，我们发现我们的代码又回来了，<strong>但是，这里有一处不同，那就是我们的 <code>effects</code>里面有两个 <code>ReactiveEffect</code>，</strong></p><p><img src="'+n+`" alt="cache-6"></p><p>事实上，从图中也可以看出来，第一个 <code>ReactiveEffect</code> 他不是我们 <code>computed</code> 的 <code>ReactiveEffect</code>，第二个才是我们 <code>computed</code> 生成的 <code>ReactiveEffect</code>，这个不同明确了以后，我们还是要执行 <code>triggerEffect(effect)</code>，</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> triggerEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">effect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ReactiveEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;trigger: 触发依赖&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (effect.scheduler) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    effect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scheduler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    effect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>第一次先执行了 <code>effect.run()</code></strong>，执行 <code>this.fn</code>，最终走到了，</p><p><img src="`+t+'" alt="cache-7"></p><p>在这里要特别注意的是 <code>computedObj.value</code>的访问，当执行到这里的时候本质上会触发 <code>computedRefImpl</code>的 <code>get value</code> 函数，</p><p><img src="'+c+'" alt="cache-8"></p><p><code>get value</code> 的触发又会执行依赖收集的操作，检查 <code>_dirty</code> 状态，此时是 <code>true</code>，<strong>然后置为<code> false</code></strong> ，所以又会执行 <code>run</code>函数，</p><p><strong>get value 依赖收集后执行 run 函数</strong></p><p><img src="'+r+'" alt="cache-9"></p><p>一旦这个 <code>fn</code> 函数执行完成，页面数据就会变成 <code>李四</code>，当我们的第一个 <code>get value</code> 执行完成后，又接着执行了第二个 <code>get value</code>，</p><p><img src="'+E+'" alt="cache-10"></p><p><img src="'+g+'" alt="cache-11"></p><p>先收集了依赖，<strong>这是第二次收集了</strong>，然后判断 <code>_dirty</code> 的状态，此时为 <code>false</code>，不会执行 <code>run</code> 函数， 最后返回 <code>this._value</code>。</p><p>其实走到这里我们希望代码就结束了，但是，我们的代码并没有结束，继续执行断点，会发现，我们的代码又回到了 <code>triggerEffects</code> 里面，这是因为我们刚刚完成的是第一轮的循环，现在我们要开始执行第二次的循环操作，这时的 <code>ReactiveEffect</code>是 <code>computed</code> 生成的 <code>ReactiveEffect</code>。</p><p><img src="'+o+'" alt="cache-12"></p><p>进入到 调度器回调函数里面，代码会再次执行 <code>triggerRefValue</code>，因为上面执行 <code>get value</code> 的时候将 <code>_dirty</code> 脏状态 只为了 <code>false</code>。</p><p><img src="'+y+'" alt="cache-13"></p><p>进入 <code>triggerRefValue</code>，再次进行派发更新的操作，</p><p><img src="'+F+`" alt="cache-14"></p><p>代码其实又回来了，这个时候我们还是要看<code>effects</code>里面是什么，没有意外，跟上面第一次开启 计算属性的 派发更新一样，我们要再一次执行上面的循环操作，循环执行这两个 <code>ReactiveEffect</code>中的 fn 函数，这样一轮又一轮的执行这个过程，造成了我们的死循环。</p><h3 id="如何解决死循环" tabindex="-1">如何解决死循环 <a class="header-anchor" href="#如何解决死循环" aria-label="Permalink to &quot;如何解决死循环&quot;">​</a></h3><p>想要解决这个死循环的问题，其实比较简单，我们只需要在 <code>packages/reactivity/src/effect.ts</code> 中的 <code>triggerEffects</code> 中修改如下代码：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> triggerEffects</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">dep</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Dep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 把 dep 构建为一个数组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effects</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isArray</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dep) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dep </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">dep]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 依次触发</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// for (const effect of effects) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 	triggerEffect(effect)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">	// 不在依次触发，而是先触发所有的计算属性依赖，再触发所有的非计算属性依赖</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> effects) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (effect.computed) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">			triggerEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(effect)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> effect</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> effects) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">effect.computed) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">			triggerEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(effect)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>那么为什么这样就可以解决死循环的 <code>bug</code> 呢？</p><p>我们再按照刚才的顺序跟踪下代码进行查看：</p><ol><li><p>延迟两秒之后，进入断点</p><img src="`+i+'" alt="cache-1" style="zoom:50%;"></li><li><p>此时执行的代码是 <code>obj.name = &#39;李四&#39;</code>，所以在 <code>target</code> 为 <code>{name: &#39;李四&#39;}</code></p></li><li><p>代码继续向下进行，进入 <code>triggerEffects(dep)</code> 方法，在 <code>triggerEffects(dep)</code> 方法中，继续进入 <code>triggerEffect(effect)</code>，</p><p><img src="'+f+'" alt="cache-15"></p></li><li><p>此时因为 <code>effect</code> 中存在 <code>scheduler</code>，所以会执行该计算属性的 <code>scheduler</code> 函数，在 <code>scheduler</code> 函数中，会触发 <code>triggerRefValue(this)</code>，而 <code>triggerRefValue</code> 则会再次触发 <code>triggerEffects</code></p><p><img src="'+a+'" alt="cache-4"></p></li><li><p><strong>不同从这里开始</strong></p><p><img src="'+n+'" alt="cache-6"></p></li><li><p>因为此时我们在 <code>triggerEffects</code> 中，增加了 <strong>判断逻辑</strong>，所以 <strong>永远会先触发</strong> 计算属性的 <code>effect</code>，所以此时再次进入到 <code>triggerEffect</code> 时，此时的 <code>effect</code> 依然为 <strong>计算属性的 <code>effect</code></strong></p><p><img src="'+u+`" alt="cache-16"></p></li><li><p>从而因为存在 <code>scheduler</code>，所以会执行：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">			// 判断当前脏的状态，如果为 false，表示需要《触发依赖》</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._dirty) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">				// 将脏置为 true，表示</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">				this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._dirty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">				triggerRefValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		})</span></span></code></pre></div><p>但是此时要注意：<strong>此时 _dirty 脏的状态</strong> 为 <code>true</code>，即：<strong>不会触发 <code>triggerRefValue</code> 来触发依赖</strong>，此次计算属性的 <code>scheduler</code> 调度器会 <strong>直接结束</strong>。</p></li><li><p>然后代码 <strong>跳回到 <code>triggerEffects</code> 两次循环中</strong>，使用 <strong>非计算属性的 <code>effect</code></strong> 执行 <code>triggerEffect</code> 方法</p><p><img src="`+A+'" alt="cache-17"></p></li><li><p>本次进入 <code>triggerEffect</code> 时，<code>effect</code> 数据如下：</p><p><img src="'+t+'" alt="cache-7"></p></li><li><p>那么这次 <code>run</code> 的执行会触发 **两次 <code>computed</code> 的 <code>get value</code>**函数</p><p>所以代码会进入到 <code>computed</code> 的 <code>get value</code> 中：</p><ol><li><p>第一次进入：</p><ol><li><p>进入 <code>computed</code> 的 <code>get value</code> ：</p></li><li><p>首先收集依赖</p></li><li><p>接下来检查 <code>dirty</code>脏的状态，执行 <code>this.effect.run()!</code></p></li><li><p>获取最新值，返回 &#39;李四&#39;</p><p><img src="'+D+'" alt="cache-18"></p><p><img src="'+C+'" alt="cache-19"></p></li></ol></li><li><p>第二次进入：</p><ol><li><p>进入 <code>computed</code> 的 <code>get value</code> ：</p></li><li><p>首先收集依赖</p></li><li><p>接下来检查 <code>dirty</code>脏的状态，**因为在上一次中 <code>dirty</code> 已经为 <code>false</code> **，所以本次 <strong>不会在触发 <code>this.effect.run()!</code></strong></p></li><li><p>直接返回结束</p><p><img src="'+m+'" alt="cache-20"></p></li></ol></li></ol></li><li><p>所有代码逻辑结束。</p></li></ol>',65)]))}const P=p(v,[["render",B]]);export{V as __pageData,P as default};
