import{_ as o,c,a0 as d,o as t}from"./chunks/framework.BFeFTQGI.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"diff/start.md","filePath":"diff/start.md"}'),n={name:"diff/start.md"};function r(s,e,a,i,p,l){return t(),c("div",null,e[0]||(e[0]=[d("<p>我们之前完成过一个 <code>patchChildren</code> 的方法，该方法的主要作用是为了 <strong>更新子节点</strong>，即：<strong>为子节点打补丁</strong>。</p><p>子节点的类型多种多样，如果两个 <code>ELEMENT</code> 的子节点都是 <code>TEXT_CHILDREN</code> 的话，那么直接通过 <code>setText</code> 附新值即可。</p><p>但是如果 <strong>新旧 <code>ELEMENT</code> 的子节点都为 <code>ARRAY_CHILDREN</code></strong> 的话，那么想要完成一个 <strong>高效</strong> 的更新就会比较复杂了。这个时候，我们就需要，<strong>比较两组子节点</strong>，以达到一个高效的更新功能。这种 <strong>比较的算法</strong> 就是 <code>diff</code> 算法。</p><p><code>vue</code> 中对 <code>diff</code> 算法的描述在 <code>packages/runtime-core/src/renderer.ts</code> 的 <code>patchKeyedChildren（1759行）</code> 方法中，观察该方法，可以发现该方法内部被分成了 <code>5</code> 块（ 5 种场景）：</p><ol><li><code>sync from start</code>：自前向后的对比</li><li><code>sync from end</code>：自后向前的对比</li><li><code>common sequence + mount</code>：新节点多于旧节点，需要挂载</li><li><code>common sequence + unmount</code>：旧节点多于新节点，需要卸载</li><li><code>unknown sequence</code>：乱序</li></ol><p>这 5 块就是 <code>diff</code> 的核心逻辑。</p>",6)]))}const g=o(n,[["render",r]]);export{m as __pageData,g as default};
