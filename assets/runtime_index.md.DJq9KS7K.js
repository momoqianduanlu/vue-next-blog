import{_ as e,c as i,a0 as n,o as a}from"./chunks/framework.BFeFTQGI.js";const k=JSON.parse('{"title":"运行时核心设计原则","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"runtime/index.md","filePath":"runtime/index.md"}'),t={name:"runtime/index.md"};function o(p,s,d,l,c,r){return a(),i("div",null,s[0]||(s[0]=[n(`<h1 id="运行时核心设计原则" tabindex="-1">运行时核心设计原则 <a class="header-anchor" href="#运行时核心设计原则" aria-label="Permalink to &quot;运行时核心设计原则&quot;">​</a></h1><h3 id="runtime-core-与-runtime-dom-的关系-为什么要这么设计" tabindex="-1"><code>runtime-core</code> 与 <code>runtime-dom</code> 的关系，为什么要这么设计 <a class="header-anchor" href="#runtime-core-与-runtime-dom-的关系-为什么要这么设计" aria-label="Permalink to &quot;\`runtime-core\` 与 \`runtime-dom\` 的关系，为什么要这么设计&quot;">​</a></h3><p>在 <code>vue</code> 源码中，关于运行时的包主要有两个：</p><ol><li><code>packages/runtime-core</code>：运行时的核心代码</li><li><code>packages/runtime-dom</code>：运行时关于浏览器渲染的代码</li></ol><p>其中第一个 <code>runtime-core</code> 的概念比较好理解，但是 <code>runtime-dom</code> 它是干什么的呢？为什么要单独分出来这样的一个包呢？</p><p>我们来看一下 <code>runtime-dom</code> 的代码，查看 <code>packages/runtime-dom/src/nodeOps.ts</code> 中的代码。</p><p>从 <code>nodeOps.ts</code> 中的代码可知，该处主要为 <strong>浏览器的 <code>web api</code></strong>。</p><p>我们知道 <code>vue</code> 的渲染主要分为两种：</p><ol><li><code>SPA</code>： 单页应用</li><li><code>SSR</code>：服务端渲染</li></ol><p>即：<code>Vue</code> 中需要处理两种不同 <strong>宿主环境</strong> ，将来还有可能会处理更多，比如 <code>windows 、android、ios应用程序</code> 等等。 在这些不同的宿主环境中，渲染 <code>DOM</code> 的方式是 <strong>完全不同</strong> 的。</p><p>所以 <code>vue</code> 就对运行时进行了处理，把所有的 <strong>浏览器的 <code>dom</code> 操作</strong>，放到了 <code>runtime-dom</code> 中，而把整个运行时的 <strong>核心代码</strong> 都放入到了 <code>runtime-core</code> 中。</p><p>通过 <strong>参数</strong> 的形式（详见 <code>packages/runtime-core/src/renderer.ts</code> 第 <code>336</code> 行 ），把 <code>DOM</code> 操作传递给了 <code>renderer</code> 渲染器 ，已达到 <strong>不同的宿主环境，可以使用不同的 <code>API</code> 的目的</strong></p><h3 id="渲染时-挂载和更新的逻辑处理" tabindex="-1">渲染时，挂载和更新的逻辑处理 <a class="header-anchor" href="#渲染时-挂载和更新的逻辑处理" aria-label="Permalink to &quot;渲染时，挂载和更新的逻辑处理&quot;">​</a></h3><p><code>packages/runtime-core/src/renderer.ts</code> 中的 <code>baseCreateRenderer</code> 是整个渲染的核心函数，我们可以利用该函数得到一个 <strong>渲染器 <code>renderer</code> 对象</strong>。</p><p><code>renderer</code> 对象中包含了一个函数 <code>render</code> 叫做 <strong>渲染函数</strong>，我们在前面使用的 <code>render</code> 函数就是它。</p><p>它接收三个参数 <code>vnode, container, isSVG</code>，我们这里不去处理 <code>isSVG</code> 这种 <strong>边缘情况</strong>。所以就把它当做只有前两个参数即可。</p><p>通过代码我们可以发现，当 <code>vnode</code> 虚拟节点存在时，会触发 <code>patch</code> 函数，即 <strong>挂载函数</strong></p><p>在 <code>patch</code> 中，根据 <code>type</code> 的类型进行了 <code>switch</code> 操作，这里的 <code>type</code> 代表的就是 <strong>节点类型</strong>，是 <code>dom 节点</code> 还是 <code>文本节点</code>。</p><p>根据 <code>switch</code> 的结果，可以触发不同的方法。我们可以随便查看几个方法，可以发现这些方法中的代码处理逻辑都差不多：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">switch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (type) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Text:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        processText</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n1, n2, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Comment:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        processCommentNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n1, n2, container, anchor)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Static:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (n1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          mountStaticNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n2, container, anchor, isSVG)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (__DEV__) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          patchStaticNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n1, n2, container, isSVG)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      case</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Fragment:</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        processFragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          n1,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          n2,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          container,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          anchor,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          parentComponent,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          parentSuspense,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          isSVG,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          slotScopeIds,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          optimized</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        )</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        break</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span></code></pre></div><p>所以说由此我们可以得到一个 <code>render</code> 的大致逻辑：</p><ol><li><code>renderer</code> 渲染器对象提供 <code>render</code> 渲染函数</li><li><code>render</code> 渲染函数在 <code>vnode</code> 存在时，触发 <code>patch</code></li><li><code>patch</code> 中根据 <code>type</code> 的类型，渲染不同的节点</li><li>节点的渲染分为 <strong>挂载</strong> 和 <strong>更新</strong></li></ol>`,22)]))}const E=e(t,[["render",o]]);export{k as __pageData,E as default};
